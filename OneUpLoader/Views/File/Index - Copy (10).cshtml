@{
    ViewBag.Title = "File Uploader";
}

@*
    TODO
    1. Disable start button.
    3. Record all errors in the fileObject collection
    4. See if you can standardise on Jquery requests only.
    5. Implement array slicing in a browser compatible way.
    6. Perform additional checks for browser support and notification.    
    9. Drop zone.
*@

<!-- Start Scripts -->

<link href="https://gitcdn.github.io/bootstrap-toggle/2.2.2/css/bootstrap-toggle.min.css" rel="stylesheet" /> <!-- Used for the Auto Resume only -->
<script src="https://gitcdn.github.io/bootstrap-toggle/2.2.2/js/bootstrap-toggle.min.js"></script>

<script>
    /*
     * JavaScript Templates
     * https://github.com/blueimp/JavaScript-Templates
     *
     * Copyright 2011, Sebastian Tschan
     * https://blueimp.net
     *
     * Licensed under the MIT license:
     * https://opensource.org/licenses/MIT
     *
     * Inspired by John Resig's JavaScript Micro-Templating:
     * http://ejohn.org/blog/javascript-micro-templating/
     */

    /* global define */
    ;
    (function($) {
        'use strict'
        var tmpl = function(str, data) {
            var f = !/[^\w\-\.:]/.test(str)
                ? tmpl.cache[str] = tmpl.cache[str] || tmpl(tmpl.load(str))
                : new Function(// eslint-disable-line no-new-func
                    tmpl.arg + ',tmpl',
                    'var _e=tmpl.encode' +
                    tmpl.helper +
                    ",_s='" +
                    str.replace(tmpl.regexp, tmpl.func) +
                    "';return _s;"
                )
            return data
                ? f(data, tmpl)
                : function(data) {
                    return f(data, tmpl)
                }
        }
        tmpl.cache = {}
        tmpl.load = function(id) {
            return document.getElementById(id).innerHTML
        }
        tmpl.regexp = /([\s'\\])(?!(?:[^{]|\{(?!%))*%\})|(?:\{%(=|#)([\s\S]+?)%\})|(\{%)|(%\})/g
        tmpl.func = function(s, p1, p2, p3, p4, p5) {
            if (p1) { // whitespace, quote and backspace in HTML context
                return {
                        '\n': '\\n',
                        '\r': '\\r',
                        '\t': '\\t',
                        ' ': ' '
                    }[p1] ||
                    '\\' + p1
            }
            if (p2) { // interpolation: {%=prop%}, or unescaped: {%#prop%}
                if (p2 === '=') {
                    return "'+_e(" + p3 + ")+'"
                }
                return "'+(" + p3 + "==null?'':" + p3 + ")+'"
            }
            if (p4) { // evaluation start tag: {%
                return "';"
            }
            if (p5) { // evaluation end tag: %}
                return "_s+='"
            }
        }
        tmpl.encReg = /[<>&"'\x00]/g // eslint-disable-line no-control-regex
        tmpl.encMap = {
            '<': '&lt;',
            '>': '&gt;',
            '&': '&amp;',
            '"': '&quot;',
            "'": '&#39;'
        }
        tmpl.encode = function(s) {
            return (s == null ? '' : '' + s).replace(
                tmpl.encReg,
                function(c) {
                    return tmpl.encMap[c] || ''
                }
            )
        }
        tmpl.arg = 'o'
        tmpl.helper = ",print=function(s,e){_s+=e?(s==null?'':s):_e(s);}" +
            ',include=function(s,d){_s+=tmpl(s,d);}'
        if (typeof define === 'function' && define.amd) {
            define(function() {
                return tmpl
            })
        } else if (typeof module === 'object' && module.exports) {
            module.exports = tmpl
        } else {
            $.tmpl = tmpl
        }
    }(this));
</script>

<script src="~/Scripts/spark-md5.js"></script>
<script language="javascript">

    // Global template variable
    var findex = 0; // store the unique index of each file template generated. //rename to UIIndex
    var totalFileInputs = 0; //rename to currentFileInputIndex
    var fileCollection = new Array();
    var autoResume = true;

    //var fcoll = {};

    // Check for the various File API support.
    if (!(XMLHttpRequest && window.File && window.FileReader && window.FileList && window.Blob))
    {
        // TODO: Add additional checks for methods which may not be supported on all browsers.
        alert('The File APIs is not fully supported in your browser.');
    }

    function uploadAll() {
        for (var i = 0; i < findex; i++) {
            // Prevent closure on a variable modified in loop
            (function(index) {
                setTimeout(function() { upload(index); }, 25);
            })(i);
        }
    }

    function upload(fileIndex)
    {
        var chunkSize = 512384; // 0.5MByte chunks

        // TODO: replace input.files with custom object containing appended browser files.
        // Get some file info.
        //var fileInfo = fileCollection[fileIndex];
        var file = fileCollection[fileIndex].file;

        var objFile = {};
        objFile.index = fileIndex;
        objFile.file = file;
        objFile.start = 0;
        objFile.end = chunkSize;
        objFile.completedChunks = 0;
        objFile.totalChunks = file.size % chunkSize === 0 ? file.size / chunkSize : Math.floor(file.size / chunkSize) + 1;
        objFile.chunkSize = chunkSize;
        objFile.error = false;
        objFile.serverFile = null;
        // Benchmark stats
        objFile.lastUploadTime = new Date();
        objFile.lastUploadBytes = 0;
        objFile.resumeTimeout = 30;
        // Save our file so we can reference it later.
        //fileInfo.objFile = objFile;

        verifyFile(objFile);
    }

    function verifyFile(objFile) {

        objFile.error = false;
        updateStatus(objFile.index, 'Checking file on server...', false);
        updateProgressBarColour(objFile.index, false);

        $.ajax({
            type: 'get',
            dataType: 'json',
            cache: false,
            url: '/File/Details?name=' + fixedEncodeURIComponent(objFile.file.name) + '&size=' + objFile.file.size,
            //data: null,//{ keyid: 1, newval: 10 },
            success: function (response, textStatus, jqXHR) {

                var serverFile = {
                    exists : false,
                    size : 0,
                    hash : ''
                };
                serverFile.exists = response.exists;
                serverFile.size = response.size;
                serverFile.hash = response.hash;

                // Resume.
                if (serverFile.exists === true)
                {
                    // Don't resume if file already uploaded.
                    if (objFile.file.size === serverFile.size) {
                        updateStatus(objFile.index, 'File exists on server.', false);
                        updateProgress(objFile.index, 100);
                        return;
                    }

                    updateStatus(objFile.index, 'File exists, resuming...', false);

                    objFile.start = serverFile.size;
                    objFile.end = objFile.start + objFile.chunkSize;
                    objFile.completedChunks = serverFile.size % objFile.chunkSize === 0 ? serverFile.size / objFile.chunkSize : Math.floor(serverFile.size / objFile.chunkSize) + 1;
                }

                objFile.serverFile = serverFile;
                uploadFile(objFile);
            },
            error: function (jqXHR, textStatus, errorThrown) {
                objFile.error = true;
                updateStatus(objFile.index, 'Error (' + textStatus + '): ' + errorThrown, true);
                updateProgressBarColour(objFile.index, true);

                if (autoResume) {
                    objFile.resumeTimeout = 5;
                    // Start resuming in 5 seconds, but first display error for 3 seconds.
                    setTimeout(function() { retryWait(objFile); }, 3000);
                }
            },
            async: true
        });
    }

    // TODO: Test replacing jquery ajax request (check performance locally and measure max bandwidth differences)
    function uploadFile(objFile)
    {
        var chunk = objFile.file.slice(objFile.start, objFile.end);

        var xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function () {
            if (objFile.error === true)
                return;

            if (xhr.readyState === 4) {
                // Note: >=200 && <300 would be more accurate than just checking for 200.
                //if (xhr.status >= 200 && xhr.status < 300)
                if (xhr.status === 200) {

                    // Prevent possibility of 200+ code failure
                    // which actually succeeds but is not supported
                    if (objFile.error === true)
                        return;

                    objFile.start = objFile.end;
                    objFile.end = objFile.start + objFile.chunkSize;
                    objFile.completedChunks++;

                    // Update statis
                    if (objFile.completedChunks === objFile.totalChunks) {
                        updateStatus(objFile.index, 'Complete.', false);
                    } else {
                        var duration = new Date().getTime() - objFile.lastUploadTime.getTime();
                        if (duration >= 1000) {
                            var bytesUploaded = objFile.start - objFile.lastUploadBytes;
                            updateStatus(objFile.index,
                                'Uploading... (' + formatBytes(bytesUploaded, 2) + ' sec)',
                                false);

                            objFile.lastUploadTime = new Date();
                            objFile.lastUploadBytes = objFile.start;
                        }
                    }

                    // Update progress.
                    var percent = Math.round((objFile.completedChunks / objFile.totalChunks * 100));
                    updateProgress(objFile.index, percent);

                    if (objFile.start < objFile.file.size)
                        uploadFile(objFile);
                } else {
                    objFile.error = true;
                    updateStatus(objFile.index, 'Error (' + xhr.statusText + '): ' + xhr.errorThrown, true);
                    updateProgressBarColour(objFile.index, true);

                    if (autoResume) {
                        objFile.resumeTimeout = 5;
                        // Start resuming in 5 seconds, but first display error for 3 seconds.
                        setTimeout(function() { retryWait(objFile); }, 3000);
                    }
                }
            }// else {
            // possibly add error handling here?
            // }
        }

        xhr.open("POST", "/File/Upload?name=" + fixedEncodeURIComponent(objFile.file.name), true);
        xhr.send(chunk);
    }

    // Provides a function for waiting between download retries.
    // Uses recursive function.
    function retryWait(objFile) {

        if (autoResume === false) {
            updateStatus(objFile.index, 'Retry aborted.', true);
            return;
        }

        if (objFile.resumeTimeout < 1) {
            // objFile.error = false;
            verifyFile(objFile);
        }
        else
        {
            updateStatus(objFile.index, 'Retrying in ' + objFile.resumeTimeout + ' sec', false);
            objFile.resumeTimeout = objFile.resumeTimeout - 1;
            setTimeout(function() { retryWait(objFile); }, 1000);
        }
    }

    // Function is fired whenever any inputFileX is changed.
    // It generates a new file input and hides the previous one
    // allowing you to upload additional files if need be.
    function getFiles(fileElement) {
        var files = fileElement.files;

        // Add files to our fileCollection global var.
        for (var i = 0; i < files.length; i++) {
            //fileCollection[findex] = {fileInputID: 'inputFile' + totalFileInputs, fileIndex: i, objFile: null};
            fileCollection[fileCollection.length] = {file: files[i]};
        }

        // Add new file entries into html.
        var uploadTemplate = tmpl("template-upload", files);
        document.getElementById("tblUploadBody").innerHTML += uploadTemplate;

        // Hide current input.
        var currentInput = $("#inputFileContainer" + totalFileInputs);
        currentInput.hide();

        // Increment input tracking counter.
        totalFileInputs++;

        // Add new input file.
        var inputFileTemplate = tmpl("template-inputFile", totalFileInputs);
        document.getElementById("fileUploadControls").innerHTML += inputFileTemplate;
    }

    function formatBytes(bytes,decimals) {
        if(bytes == 0) return '0 Bytes';
        var k = 1000,
            dm = decimals || 2,
            sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }

    function fixedEncodeURIComponent (str) {
        return encodeURIComponent(str).replace(/[!'()]/g, escape).replace(/\*/g, "%2A");
    }

    function updateStatus(index, msg, isError) {
        if (isError)
            msg = "<span style='color:red;'>" + msg + "</span>";
        else
            msg = "<span style='color:black;'>" + msg + "</span>";
        $("#fileStatus" + index).html(msg);
    }

    function updateProgress(index, percent) {
        var progressElement = $("#fileProgress" + index);
        progressElement.attr('aria-valuenow', percent);
        progressElement.children().text(percent + '%');
        progressElement.children().css('width', percent + '%');
    }

    function updateProgressBarColour(index, isError) {
        var progressElement = $("#fileProgress" + index);

        if (isError) {
            progressElement.children().removeClass('progress-bar-danger');
            progressElement.children().removeClass('progress-bar-success');
            progressElement.children().addClass('progress-bar-danger');
        } else {
            progressElement.children().removeClass('progress-bar-danger');
            progressElement.children().removeClass('progress-bar-success');
            progressElement.children().addClass('progress-bar-success');
        }
    }

    function resumeChanged(checkbox) {
        autoResume = checkbox.checked;
    }
</script>

<!-- End Scripts -->

<!-- Start Content -->

<div class="jumbotron">
    Upload
</div>

<div class="row" id="drop-zone">
    <div class="col-md-12" style="font-size: 14px;">
        <div class="row fileupload-buttonbar">
            <div class="col-lg-12">
                <!-- The fileinput-button span is used to style the file input field as button -->                    
                <span id="fileUploadControls">
                    <label id="inputFileContainer0" class="btn btn-default" for="inputFile0">
                        <input id="inputFile0" type="file" style="display:none" onchange="getFiles(this)" multiple>
                        <i class="glyphicon glyphicon-plus"></i> Choose file...
                    </label>
                </span>
                <button type="submit" class="btn btn-primary" onclick="uploadAll();">
                    <i class="glyphicon glyphicon-upload"></i>
                    <span>Start upload</span>
                </button>
                <button type="reset" class="btn btn-warning" onclick="alert('not implemented!');">
                    <i class="glyphicon glyphicon-ban-circle"></i>
                    <span>Cancel upload</span>
                </button>
                <button type="button" class="btn btn-danger" onclick="alert('not implemented!');">
                    <i class="glyphicon glyphicon-trash"></i>
                    <span>Delete</span>
                </button>    
                <span style="float: right;">
                    <label class="checkbox-inline">
                        Auto Resume &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                        <input type="checkbox" data-toggle="toggle" checked onchange="resumeChanged(this)" data-onstyle="success">
                    </label>
                </span>                                           
            </div>
            @*<!-- The global progress state -->
            <div class="col-lg-5 fileupload-progress fade">
                <!-- The global progress bar -->
                <div class="progress progress-striped active" role="progressbar" aria-valuemin="0" aria-valuemax="100">
                    <div class="progress-bar progress-bar-success" style="width:0%;"></div>
                </div>
                <!-- The extended global progress state -->
                <div class="progress-extended">&nbsp;</div>
            </div>
            <br />*@
        </div>
        <div>
            <table class="table table-responsive">
                <thead>
                    <tr>
                        <th style="width: 5%;">#</th>
                        <th style="width: 40%;">Filename</th>
                        <th style="width: 8%;">Size</th>
                        <th style="width: 20%;">Status</th>
                        <th style="width: 15%;">Progress</th>
                        <th style="width: 17%;">Actions</th>
                    </tr>
                </thead>
                <tbody id="tblUploadBody"></tbody>
            </table>
        </div>
    </div>
</div>

<!-- End Content -->

<!-- Start Templates -->

<script id="template-upload" type="text/x-tmpl">
    {% for (var i=0; i < o.length; i++) { %}
    <tr id="uiFile{%=findex%}">
        <th scope="row">{%=(findex+1)%}</th>
        <td style="word-wrap: break-word;min-width: 160px;max-width: 160px;">
            <p class="name">{%=((o[i].name.length > 40) ? o[i].name.substr(0,41) + "..." : o[i].name)%}</p>
            <strong class="error text-danger"></strong>
        </td>
        <td>
            <p class="size">{%=formatBytes(o[i].size, 2)%}</p>
        </td>
        <td>
            <p id="fileStatus{%=findex%}" class="size">Pending </p>
        </td>
        <td>
            <div id="fileProgress{%=findex%}" style="width: 100%;" class="progress progress-striped active" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                <div class="progress-bar progress-bar-success" style="width:0%;padding-top:2px;"></div>
            </div>
        </td>
        <td>
            <button class="btn btn-primary btn-xs start" onclick="upload({%=findex%});">
                <i class="glyphicon glyphicon-upload"></i>
                <span>Start</span>
            </button>
            <button class="btn btn-warning btn-xs cancel" disabled onclick="alert('not implemented!');">
                <i class="glyphicon glyphicon-ban-circle"></i>
                <span>Stop</span>
            </button>
        </td>
    </tr>
    {%findex++;%}
    {% } %}

</script>

<script id="template-inputFile" type="text/x-tmpl">
    <label id="inputFileContainer{%=o%}" class="btn btn-default" for="inputFile{%=o%}">
        <input id="inputFile{%=o%}" type="file" style="display:none" onchange="getFiles(this)" multiple>
        <i class="glyphicon glyphicon-plus"></i> Choose file...
    </label>
</script>

<!-- End Templates -->


<script>
    
    //$('#drop-zone').dropZone();

    //document.getElementById('file1').addEventListener('change', function () {
    //    var blobSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice,
    //        file = this.files[0],
    //        chunkSize = 2097152,                             // Read in chunks of 2MB
    //        chunks = Math.ceil(file.size / chunkSize),
    //        currentChunk = 0,
    //        spark = new SparkMD5.ArrayBuffer(),
    //        fileReader = new FileReader();

    //    fileReader.onload = function (e) {
    //        console.log('read chunk nr', currentChunk + 1, 'of', chunks);
    //        spark.append(e.target.result);                   // Append array buffer
    //        currentChunk++;

    //        document.getElementById('info').innerHTML = '' + (Math.round(currentChunk / chunks)*100) + '%';

    //        if (currentChunk < chunks) {
    //            setTimeout(loadNext(), 10);
    //            //loadNext();
    //        } else {
    //            console.log('finished loading');
    //            console.info('computed hash', spark.end());  // Compute hash
    //            document.getElementById('info').innerHTML = 'finished!';
    //        }
    //    };

    //    fileReader.onerror = function () {
    //        console.warn('oops, something went wrong.');
    //    };

    //    function loadNext() {
    //        var start = currentChunk * chunkSize,
    //            end = ((start + chunkSize) >= file.size) ? file.size : start + chunkSize;

    //        setTimeout(fileReader.readAsArrayBuffer(blobSlice.call(file, start, end)), 1);
    //        //fileReader.readAsArrayBuffer(blobSlice.call(file, start, end));
    //    }

    //    loadNext();
    //});

    /*function uploadNextChunk(xhr, objFile)
        { 
            var chunk = objFile.file.slice(objFile.start, objFile.end);
      
            this.xhr = new XMLHttpRequest();
            xhr.addEventListener("load", transfer_complete, false);
            xhr.addEventListener("error", transfer_failed, false);
            xhr.addEventListener("abort", transfer_canceled, false);
            if (xhr.upload)
                xhr.upload.onprogress = progressUpdate;
            xhr.onprogress = progressUpdate;
            //xhr.onreadystatechange = request_complete(xhr, objFile);
            xhr.onreadystatechange = function () {
                if (objFile.error)
                    return;
      
                if (xhr.readyState === 4) {
                    //if (xhr.status >= 200 && xhr.status < 300)
                    if (xhr.status === 200) {
                        objFile.start = objFile.end;
                        objFile.end = objFile.start + objFile.chunkSize;
                        objFile.completedChunks++;
      
                        // Update progress.
                        var percent = Math.round((objFile.completedChunks / objFile.totalChunks * 100));
                        var progressElement = $("#fileProgress" + objFile.index);
                        progressElement.attr('aria-valuenow', percent);
                        progressElement.children().text(percent + '%');
                        progressElement.children().css('width', percent);
      
                        if (objFile.start < objFile.file.size)
                            uploadNextChunk(xhr, objFile);
                    } else {
                        alert("Error: status=" + xhr.status + " and reason=" +  xhr.statusText);
                        console.log("Error", xhr.statusText);
                        objFile.error = true;
                    }
                }
            }
      
            xhr.open("POST", "/File/Upload?fileName=" + objFile.file.name, true);
            xhr.send(chunk);
        }*/

</script>
